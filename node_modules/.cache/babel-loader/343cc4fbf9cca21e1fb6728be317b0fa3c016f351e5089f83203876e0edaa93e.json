{"ast":null,"code":"var _jsxFileName = \"C:\\\\wamp64\\\\www\\\\memory-react\\\\src\\\\App.js\",\n  _s = $RefreshSig$();\n// ============================================================================\n// IMPORTS - Importation des modules et composants n√©cessaires\n// ============================================================================\n\n// Import de React et des hooks (useState pour g√©rer l'√©tat, useEffect pour les effets de bord)\nimport React, { useState, useEffect } from 'react';\n\n// Import du fichier CSS pour styliser ce composant\nimport './App.css';\n\n// Import des composants enfants que nous avons cr√©√©s\nimport Title from './components/Title/Title'; // Composant pour afficher le titre\nimport Button from './components/Button/Button'; // Composant bouton r√©utilisable\nimport Card from './components/Card/Card'; // Composant carte du jeu\n\n// ============================================================================\n// CONSTANTES GLOBALES\n// ============================================================================\n\n// Tableau contenant les 8 symboles uniques qui seront utilis√©s pour les cartes\n// Chaque symbole sera dupliqu√© pour cr√©er les paires (16 cartes au total)\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst cardSymbols = ['üéÆ', 'üéØ', 'üé®', 'üé≠', 'üé™', 'üé∏', 'üé≤', 'üé∞'];\n\n// ============================================================================\n// COMPOSANT PRINCIPAL APP\n// ============================================================================\n\nfunction App() {\n  _s();\n  // ==========================================================================\n  // STATES - Variables d'√©tat qui d√©clenchent un re-rendu quand elles changent\n  // ==========================================================================\n\n  // cards : Tableau contenant toutes les cartes du jeu (16 cartes)\n  // Chaque carte est un objet avec { id: nombre, value: emoji }\n  // setCards : Fonction pour modifier le state cards\n  const [cards, setCards] = useState([]);\n\n  // flippedCards : Tableau des cartes actuellement retourn√©es (maximum 2)\n  // Contient les objets carte que le joueur a cliqu√©\n  // setFlippedCards : Fonction pour modifier le state flippedCards\n  const [flippedCards, setFlippedCards] = useState([]);\n\n  // matchedPairs : Tableau contenant les symboles des paires d√©j√† trouv√©es\n  // Exemple : ['üéÆ', 'üéØ'] signifie que ces 2 paires ont √©t√© trouv√©es\n  // setMatchedPairs : Fonction pour modifier le state matchedPairs\n  const [matchedPairs, setMatchedPairs] = useState([]);\n\n  // moves : Nombre de coups jou√©s par le joueur (nombre de tentatives)\n  // Incr√©ment√© chaque fois que 2 cartes sont retourn√©es\n  // setMoves : Fonction pour modifier le state moves\n  const [moves, setMoves] = useState(0);\n\n  // gameWon : Bool√©en indiquant si le jeu est gagn√© (true) ou non (false)\n  // Passe √† true quand toutes les paires sont trouv√©es\n  // setGameWon : Fonction pour modifier le state gameWon\n  const [gameWon, setGameWon] = useState(false);\n\n  // timer : Nombre de secondes √©coul√©es depuis le d√©but de la partie\n  // S'incr√©mente de 1 chaque seconde\n  // setTimer : Fonction pour modifier le state timer\n  const [timer, setTimer] = useState(0);\n\n  // isTimerRunning : Bool√©en indiquant si le chronom√®tre est actif\n  // true = le timer compte, false = le timer est arr√™t√©\n  // setIsTimerRunning : Fonction pour modifier le state isTimerRunning\n  const [isTimerRunning, setIsTimerRunning] = useState(false);\n\n  // ==========================================================================\n  // EFFET 1 - Initialisation du jeu au chargement du composant\n  // ==========================================================================\n\n  // useEffect est un hook qui ex√©cute du code apr√®s le rendu du composant\n  // Le tableau vide [] signifie : ex√©cuter seulement une fois au montage du composant\n  useEffect(() => {\n    // Appeler la fonction initializeGame() pour pr√©parer le jeu\n    initializeGame();\n  }, []); // [] = d√©pendances vides = ne s'ex√©cute qu'une seule fois\n\n  // ==========================================================================\n  // EFFET 2 - Gestion du chronom√®tre\n  // ==========================================================================\n\n  // Ce useEffect g√®re le timer qui s'incr√©mente chaque seconde\n  // Il s'ex√©cute chaque fois que isTimerRunning change\n  useEffect(() => {\n    // D√©claration d'une variable pour stocker l'identifiant de l'intervalle\n    let interval = null;\n\n    // Si le timer doit √™tre actif\n    if (isTimerRunning) {\n      // setInterval ex√©cute une fonction toutes les X millisecondes (ici 1000ms = 1 seconde)\n      interval = setInterval(() => {\n        // Mettre √† jour le timer en ajoutant 1 seconde\n        // prevTimer est la valeur pr√©c√©dente du timer (garantit la bonne valeur)\n        setTimer(prevTimer => prevTimer + 1);\n      }, 1000); // 1000 millisecondes = 1 seconde\n    } else {\n      // Si le timer n'est pas actif, arr√™ter l'intervalle\n      clearInterval(interval);\n    }\n\n    // Fonction de nettoyage : ex√©cut√©e quand le composant est d√©truit\n    // ou quand isTimerRunning change (avant le prochain useEffect)\n    // Important pour √©viter les fuites m√©moire\n    return () => clearInterval(interval);\n  }, [isTimerRunning]); // Ce useEffect se r√©-ex√©cute quand isTimerRunning change\n\n  // ==========================================================================\n  // FONCTION - Initialiser ou r√©initialiser le jeu\n  // ==========================================================================\n\n  // Cette fonction cr√©e un nouveau jeu et remet tous les states √† z√©ro\n  // Elle est appel√©e au d√©marrage et quand on clique sur \"Nouvelle Partie\"\n  const initializeGame = () => {\n    // -------------------------\n    // Cr√©ation des cartes\n    // -------------------------\n\n    // √âtape 1 : [...cardSymbols, ...cardSymbols]\n    // Le spread operator (...) duplique le tableau cardSymbols\n    // R√©sultat : ['üéÆ', 'üéØ', 'üé®', 'üé≠', 'üé™', 'üé∏', 'üé≤', 'üé∞', 'üéÆ', 'üéØ', 'üé®', 'üé≠', 'üé™', 'üé∏', 'üé≤', 'üé∞']\n    // On a maintenant 16 √©l√©ments (8 paires)\n\n    // √âtape 2 : .sort(() => Math.random() - 0.5)\n    // M√©lange al√©atoirement le tableau\n    // Math.random() retourne un nombre entre 0 et 1\n    // Si r√©sultat < 0.5 : ordre n√©gatif (a avant b)\n    // Si r√©sultat > 0.5 : ordre positif (b avant a)\n    // Cela cr√©e un m√©lange al√©atoire des cartes\n\n    // √âtape 3 : .map((value, index) => ({ id: index, value: value }))\n    // Transforme chaque emoji en objet carte\n    // value : l'emoji actuel (ex: 'üéÆ')\n    // index : la position dans le tableau (0, 1, 2, ...)\n    // Retourne un objet : { id: 0, value: 'üéÆ' }\n    const shuffledCards = [...cardSymbols, ...cardSymbols].sort(() => Math.random() - 0.5).map((value, index) => ({\n      id: index,\n      // Identifiant unique pour chaque carte\n      value: value // Le symbole de la carte (emoji)\n    }));\n\n    // -------------------------\n    // R√©initialisation des states\n    // -------------------------\n\n    setCards(shuffledCards); // Mettre √† jour le tableau de cartes\n    setFlippedCards([]); // Aucune carte retourn√©e\n    setMatchedPairs([]); // Aucune paire trouv√©e\n    setMoves(0); // Remettre le compteur de coups √† 0\n    setGameWon(false); // Le jeu n'est pas gagn√©\n    setTimer(0); // Remettre le timer √† 0\n    setIsTimerRunning(false); // Arr√™ter le timer\n  };\n\n  // ==========================================================================\n  // FONCTION - G√©rer le clic sur une carte\n  // ==========================================================================\n\n  // Cette fonction est appel√©e quand le joueur clique sur une carte\n  // Param√®tre : card (objet contenant { id: nombre, value: emoji })\n  const handleCardClick = card => {\n    // -------------------------\n    // V√©rification 1 : D√©marrer le timer au premier clic\n    // -------------------------\n\n    // Si c'est le premier coup (moves === 0) ET que le timer n'est pas d√©j√† lanc√©\n    if (moves === 0 && !isTimerRunning) {\n      setIsTimerRunning(true); // D√©marrer le chronom√®tre\n    }\n\n    // -------------------------\n    // V√©rification 2 : Bloquer si 2 cartes sont d√©j√† retourn√©es\n    // -------------------------\n\n    // Si deux cartes sont d√©j√† retourn√©es, ne rien faire\n    // (on attend qu'elles se retournent ou qu'elles restent visibles si c'est une paire)\n    if (flippedCards.length === 2) {\n      return; // Sortir de la fonction imm√©diatement\n    }\n\n    // -------------------------\n    // V√©rification 3 : Emp√™cher de cliquer deux fois sur la m√™me carte\n    // -------------------------\n\n    // .find() cherche un √©l√©ment dans le tableau flippedCards\n    // Retourne l'√©l√©ment si trouv√©, sinon undefined\n    // Si la carte cliqu√©e est d√©j√† dans flippedCards, ne rien faire\n    if (flippedCards.find(c => c.id === card.id)) {\n      return; // Sortir de la fonction\n    }\n\n    // -------------------------\n    // Ajouter la carte aux cartes retourn√©es\n    // -------------------------\n\n    // Cr√©er un nouveau tableau avec les cartes d√©j√† retourn√©es + la nouvelle carte\n    // [...flippedCards] : copie du tableau existant\n    // , card : ajout de la nouvelle carte\n    const newFlippedCards = [...flippedCards, card];\n\n    // Mettre √† jour le state avec le nouveau tableau\n    setFlippedCards(newFlippedCards);\n\n    // -------------------------\n    // Si deux cartes sont maintenant retourn√©es\n    // -------------------------\n\n    if (newFlippedCards.length === 2) {\n      // Incr√©menter le compteur de coups (moves + 1)\n      setMoves(moves + 1);\n\n      // -------------------------\n      // V√©rifier si les deux cartes ont le m√™me symbole\n      // -------------------------\n\n      // newFlippedCards[0] : premi√®re carte retourn√©e\n      // newFlippedCards[1] : deuxi√®me carte retourn√©e\n      // .value : le symbole (emoji) de la carte\n      if (newFlippedCards[0].value === newFlippedCards[1].value) {\n        // ‚úÖ PAIRE TROUV√âE !\n\n        // Ajouter le symbole de la paire trouv√©e au tableau matchedPairs\n        const newMatchedPairs = [...matchedPairs, newFlippedCards[0].value];\n        setMatchedPairs(newMatchedPairs);\n\n        // Vider le tableau des cartes retourn√©es (elles restent visibles car matched)\n        setFlippedCards([]);\n\n        // -------------------------\n        // V√©rifier si toutes les paires sont trouv√©es (victoire)\n        // -------------------------\n\n        // Si le nombre de paires trouv√©es === nombre de symboles uniques\n        // Alors le joueur a gagn√© !\n        if (newMatchedPairs.length === cardSymbols.length) {\n          setGameWon(true); // Marquer le jeu comme gagn√©\n          setIsTimerRunning(false); // Arr√™ter le chronom√®tre\n        }\n      } else {\n        // ‚ùå PAS DE CORRESPONDANCE\n\n        // setTimeout ex√©cute une fonction apr√®s un d√©lai (en millisecondes)\n        // Ici : attendre 1000ms (1 seconde) avant de retourner les cartes\n        // Cela donne le temps au joueur de voir les deux cartes\n        setTimeout(() => {\n          setFlippedCards([]); // Vider le tableau = retourner les cartes\n        }, 1000); // 1000 millisecondes = 1 seconde\n      }\n    }\n  };\n\n  // ==========================================================================\n  // FONCTION - Formater le temps en format MM:SS\n  // ==========================================================================\n\n  // Cette fonction convertit un nombre de secondes en format \"minutes:secondes\"\n  // Param√®tre : seconds (nombre de secondes, ex: 125)\n  // Retourne : une cha√Æne format√©e (ex: \"02:05\")\n  const formatTime = seconds => {\n    // Calculer les minutes : diviser les secondes par 60 et arrondir vers le bas\n    // Math.floor() arrondit vers le bas (ex: 2.9 devient 2)\n    // Exemple : 125 secondes / 60 = 2.08... => Math.floor = 2 minutes\n    const mins = Math.floor(seconds / 60);\n\n    // Calculer les secondes restantes : modulo (%) donne le reste de la division\n    // Exemple : 125 % 60 = 5 secondes\n    const secs = seconds % 60;\n\n    // Cr√©er la cha√Æne format√©e avec template literals (backticks `)\n    // .toString() : convertir le nombre en cha√Æne\n    // .padStart(2, '0') : ajouter un 0 devant si le nombre a moins de 2 chiffres\n    // Exemple : 2 => \"02\", 5 => \"05\"\n    // R√©sultat final : \"02:05\"\n    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n  };\n\n  // ==========================================================================\n  // RENDU JSX - Ce que le composant affiche √† l'√©cran\n  // ==========================================================================\n\n  // return contient le JSX (HTML dans JavaScript) √† afficher\n  return (\n    /*#__PURE__*/\n    // Div principale avec la classe CSS \"App\"\n    _jsxDEV(\"div\", {\n      className: \"App\",\n      children: [/*#__PURE__*/_jsxDEV(Title, {\n        text: \"Memory Game\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 292,\n        columnNumber: 7\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"game-info\",\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"info-item\",\n          children: [/*#__PURE__*/_jsxDEV(\"span\", {\n            className: \"info-label\",\n            children: \"Coups:\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 300,\n            columnNumber: 11\n          }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n            className: \"info-value\",\n            children: moves\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 302,\n            columnNumber: 11\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 299,\n          columnNumber: 9\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"info-item\",\n          children: [/*#__PURE__*/_jsxDEV(\"span\", {\n            className: \"info-label\",\n            children: \"Temps:\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 307,\n            columnNumber: 11\n          }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n            className: \"info-value\",\n            children: formatTime(timer)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 309,\n            columnNumber: 11\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 306,\n          columnNumber: 9\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"info-item\",\n          children: [/*#__PURE__*/_jsxDEV(\"span\", {\n            className: \"info-label\",\n            children: \"Paires:\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 314,\n            columnNumber: 11\n          }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n            className: \"info-value\",\n            children: [matchedPairs.length, \"/\", cardSymbols.length]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 318,\n            columnNumber: 11\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 313,\n          columnNumber: 9\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 297,\n        columnNumber: 7\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"cards-grid\",\n        children: cards.map(card =>\n        /*#__PURE__*/\n        // key : identifiant unique requis par React pour les listes\n        // Permet √† React de savoir quelle carte a chang√©\n        // card : passe l'objet carte complet au composant Card\n        // handleCardClick : passe la fonction de clic au composant Card\n        // isFlipped : v√©rifie si la carte est dans le tableau flippedCards\n        //   .some() retourne true si au moins un √©l√©ment correspond\n        //   (c) => c.id === card.id : fonction qui compare les IDs\n        // isMatched : v√©rifie si le symbole de la carte est dans matchedPairs\n        //   .includes() retourne true si l'√©l√©ment est dans le tableau\n        _jsxDEV(Card, {\n          card: card,\n          handleCardClick: handleCardClick,\n          isFlipped: flippedCards.some(c => c.id === card.id),\n          isMatched: matchedPairs.includes(card.value)\n        }, card.id, false, {\n          fileName: _jsxFileName,\n          lineNumber: 338,\n          columnNumber: 11\n        }, this))\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 325,\n        columnNumber: 7\n      }, this), gameWon && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"victory-message\",\n        children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n          children: \"\\uD83C\\uDF89 F\\xE9licitations ! \\uD83C\\uDF89\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 355,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n          children: [\"Vous avez gagn\\xE9 en \", moves, \" coups et \", formatTime(timer), \" !\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 357,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 354,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"button-container\",\n        children: /*#__PURE__*/_jsxDEV(Button, {\n          text: \"Nouvelle Partie\",\n          onClick: initializeGame\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 368,\n          columnNumber: 9\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 364,\n        columnNumber: 7\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 285,\n      columnNumber: 5\n    }, this)\n  );\n}\n\n// ============================================================================\n// EXPORT - Rendre le composant accessible aux autres fichiers\n// ============================================================================\n\n// export default permet d'importer ce composant avec : import App from './App'\n_s(App, \"x5c3YN6YFfOmkeq1SiMC0fWX9uM=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","useEffect","Title","Button","Card","jsxDEV","_jsxDEV","cardSymbols","App","_s","cards","setCards","flippedCards","setFlippedCards","matchedPairs","setMatchedPairs","moves","setMoves","gameWon","setGameWon","timer","setTimer","isTimerRunning","setIsTimerRunning","initializeGame","interval","setInterval","prevTimer","clearInterval","shuffledCards","sort","Math","random","map","value","index","id","handleCardClick","card","length","find","c","newFlippedCards","newMatchedPairs","setTimeout","formatTime","seconds","mins","floor","secs","toString","padStart","className","children","text","fileName","_jsxFileName","lineNumber","columnNumber","isFlipped","some","isMatched","includes","onClick","_c","$RefreshReg$"],"sources":["C:/wamp64/www/memory-react/src/App.js"],"sourcesContent":["// ============================================================================\r\n// IMPORTS - Importation des modules et composants n√©cessaires\r\n// ============================================================================\r\n\r\n// Import de React et des hooks (useState pour g√©rer l'√©tat, useEffect pour les effets de bord)\r\nimport React, { useState, useEffect } from 'react';\r\n\r\n// Import du fichier CSS pour styliser ce composant\r\nimport './App.css';\r\n\r\n// Import des composants enfants que nous avons cr√©√©s\r\nimport Title from './components/Title/Title';   // Composant pour afficher le titre\r\nimport Button from './components/Button/Button'; // Composant bouton r√©utilisable\r\nimport Card from './components/Card/Card';       // Composant carte du jeu\r\n\r\n// ============================================================================\r\n// CONSTANTES GLOBALES\r\n// ============================================================================\r\n\r\n// Tableau contenant les 8 symboles uniques qui seront utilis√©s pour les cartes\r\n// Chaque symbole sera dupliqu√© pour cr√©er les paires (16 cartes au total)\r\nconst cardSymbols = ['üéÆ', 'üéØ', 'üé®', 'üé≠', 'üé™', 'üé∏', 'üé≤', 'üé∞'];\r\n\r\n// ============================================================================\r\n// COMPOSANT PRINCIPAL APP\r\n// ============================================================================\r\n\r\nfunction App() {\r\n  // ==========================================================================\r\n  // STATES - Variables d'√©tat qui d√©clenchent un re-rendu quand elles changent\r\n  // ==========================================================================\r\n  \r\n  // cards : Tableau contenant toutes les cartes du jeu (16 cartes)\r\n  // Chaque carte est un objet avec { id: nombre, value: emoji }\r\n  // setCards : Fonction pour modifier le state cards\r\n  const [cards, setCards] = useState([]);\r\n  \r\n  // flippedCards : Tableau des cartes actuellement retourn√©es (maximum 2)\r\n  // Contient les objets carte que le joueur a cliqu√©\r\n  // setFlippedCards : Fonction pour modifier le state flippedCards\r\n  const [flippedCards, setFlippedCards] = useState([]);\r\n  \r\n  // matchedPairs : Tableau contenant les symboles des paires d√©j√† trouv√©es\r\n  // Exemple : ['üéÆ', 'üéØ'] signifie que ces 2 paires ont √©t√© trouv√©es\r\n  // setMatchedPairs : Fonction pour modifier le state matchedPairs\r\n  const [matchedPairs, setMatchedPairs] = useState([]);\r\n  \r\n  // moves : Nombre de coups jou√©s par le joueur (nombre de tentatives)\r\n  // Incr√©ment√© chaque fois que 2 cartes sont retourn√©es\r\n  // setMoves : Fonction pour modifier le state moves\r\n  const [moves, setMoves] = useState(0);\r\n  \r\n  // gameWon : Bool√©en indiquant si le jeu est gagn√© (true) ou non (false)\r\n  // Passe √† true quand toutes les paires sont trouv√©es\r\n  // setGameWon : Fonction pour modifier le state gameWon\r\n  const [gameWon, setGameWon] = useState(false);\r\n  \r\n  // timer : Nombre de secondes √©coul√©es depuis le d√©but de la partie\r\n  // S'incr√©mente de 1 chaque seconde\r\n  // setTimer : Fonction pour modifier le state timer\r\n  const [timer, setTimer] = useState(0);\r\n  \r\n  // isTimerRunning : Bool√©en indiquant si le chronom√®tre est actif\r\n  // true = le timer compte, false = le timer est arr√™t√©\r\n  // setIsTimerRunning : Fonction pour modifier le state isTimerRunning\r\n  const [isTimerRunning, setIsTimerRunning] = useState(false);\r\n\r\n  // ==========================================================================\r\n  // EFFET 1 - Initialisation du jeu au chargement du composant\r\n  // ==========================================================================\r\n  \r\n  // useEffect est un hook qui ex√©cute du code apr√®s le rendu du composant\r\n  // Le tableau vide [] signifie : ex√©cuter seulement une fois au montage du composant\r\n  useEffect(() => {\r\n    // Appeler la fonction initializeGame() pour pr√©parer le jeu\r\n    initializeGame();\r\n  }, []); // [] = d√©pendances vides = ne s'ex√©cute qu'une seule fois\r\n\r\n  // ==========================================================================\r\n  // EFFET 2 - Gestion du chronom√®tre\r\n  // ==========================================================================\r\n  \r\n  // Ce useEffect g√®re le timer qui s'incr√©mente chaque seconde\r\n  // Il s'ex√©cute chaque fois que isTimerRunning change\r\n  useEffect(() => {\r\n    // D√©claration d'une variable pour stocker l'identifiant de l'intervalle\r\n    let interval = null;\r\n    \r\n    // Si le timer doit √™tre actif\r\n    if (isTimerRunning) {\r\n      // setInterval ex√©cute une fonction toutes les X millisecondes (ici 1000ms = 1 seconde)\r\n      interval = setInterval(() => {\r\n        // Mettre √† jour le timer en ajoutant 1 seconde\r\n        // prevTimer est la valeur pr√©c√©dente du timer (garantit la bonne valeur)\r\n        setTimer((prevTimer) => prevTimer + 1);\r\n      }, 1000); // 1000 millisecondes = 1 seconde\r\n    } else {\r\n      // Si le timer n'est pas actif, arr√™ter l'intervalle\r\n      clearInterval(interval);\r\n    }\r\n    \r\n    // Fonction de nettoyage : ex√©cut√©e quand le composant est d√©truit\r\n    // ou quand isTimerRunning change (avant le prochain useEffect)\r\n    // Important pour √©viter les fuites m√©moire\r\n    return () => clearInterval(interval);\r\n  }, [isTimerRunning]); // Ce useEffect se r√©-ex√©cute quand isTimerRunning change\r\n\r\n  // ==========================================================================\r\n  // FONCTION - Initialiser ou r√©initialiser le jeu\r\n  // ==========================================================================\r\n  \r\n  // Cette fonction cr√©e un nouveau jeu et remet tous les states √† z√©ro\r\n  // Elle est appel√©e au d√©marrage et quand on clique sur \"Nouvelle Partie\"\r\n  const initializeGame = () => {\r\n    // -------------------------\r\n    // Cr√©ation des cartes\r\n    // -------------------------\r\n    \r\n    // √âtape 1 : [...cardSymbols, ...cardSymbols]\r\n    // Le spread operator (...) duplique le tableau cardSymbols\r\n    // R√©sultat : ['üéÆ', 'üéØ', 'üé®', 'üé≠', 'üé™', 'üé∏', 'üé≤', 'üé∞', 'üéÆ', 'üéØ', 'üé®', 'üé≠', 'üé™', 'üé∏', 'üé≤', 'üé∞']\r\n    // On a maintenant 16 √©l√©ments (8 paires)\r\n    \r\n    // √âtape 2 : .sort(() => Math.random() - 0.5)\r\n    // M√©lange al√©atoirement le tableau\r\n    // Math.random() retourne un nombre entre 0 et 1\r\n    // Si r√©sultat < 0.5 : ordre n√©gatif (a avant b)\r\n    // Si r√©sultat > 0.5 : ordre positif (b avant a)\r\n    // Cela cr√©e un m√©lange al√©atoire des cartes\r\n    \r\n    // √âtape 3 : .map((value, index) => ({ id: index, value: value }))\r\n    // Transforme chaque emoji en objet carte\r\n    // value : l'emoji actuel (ex: 'üéÆ')\r\n    // index : la position dans le tableau (0, 1, 2, ...)\r\n    // Retourne un objet : { id: 0, value: 'üéÆ' }\r\n    const shuffledCards = [...cardSymbols, ...cardSymbols]\r\n      .sort(() => Math.random() - 0.5)\r\n      .map((value, index) => ({\r\n        id: index,        // Identifiant unique pour chaque carte\r\n        value: value,     // Le symbole de la carte (emoji)\r\n      }));\r\n\r\n    // -------------------------\r\n    // R√©initialisation des states\r\n    // -------------------------\r\n    \r\n    setCards(shuffledCards);        // Mettre √† jour le tableau de cartes\r\n    setFlippedCards([]);            // Aucune carte retourn√©e\r\n    setMatchedPairs([]);            // Aucune paire trouv√©e\r\n    setMoves(0);                    // Remettre le compteur de coups √† 0\r\n    setGameWon(false);              // Le jeu n'est pas gagn√©\r\n    setTimer(0);                    // Remettre le timer √† 0\r\n    setIsTimerRunning(false);       // Arr√™ter le timer\r\n  };\r\n\r\n  // ==========================================================================\r\n  // FONCTION - G√©rer le clic sur une carte\r\n  // ==========================================================================\r\n  \r\n  // Cette fonction est appel√©e quand le joueur clique sur une carte\r\n  // Param√®tre : card (objet contenant { id: nombre, value: emoji })\r\n  const handleCardClick = (card) => {\r\n    // -------------------------\r\n    // V√©rification 1 : D√©marrer le timer au premier clic\r\n    // -------------------------\r\n    \r\n    // Si c'est le premier coup (moves === 0) ET que le timer n'est pas d√©j√† lanc√©\r\n    if (moves === 0 && !isTimerRunning) {\r\n      setIsTimerRunning(true); // D√©marrer le chronom√®tre\r\n    }\r\n\r\n    // -------------------------\r\n    // V√©rification 2 : Bloquer si 2 cartes sont d√©j√† retourn√©es\r\n    // -------------------------\r\n    \r\n    // Si deux cartes sont d√©j√† retourn√©es, ne rien faire\r\n    // (on attend qu'elles se retournent ou qu'elles restent visibles si c'est une paire)\r\n    if (flippedCards.length === 2) {\r\n      return; // Sortir de la fonction imm√©diatement\r\n    }\r\n\r\n    // -------------------------\r\n    // V√©rification 3 : Emp√™cher de cliquer deux fois sur la m√™me carte\r\n    // -------------------------\r\n    \r\n    // .find() cherche un √©l√©ment dans le tableau flippedCards\r\n    // Retourne l'√©l√©ment si trouv√©, sinon undefined\r\n    // Si la carte cliqu√©e est d√©j√† dans flippedCards, ne rien faire\r\n    if (flippedCards.find((c) => c.id === card.id)) {\r\n      return; // Sortir de la fonction\r\n    }\r\n\r\n    // -------------------------\r\n    // Ajouter la carte aux cartes retourn√©es\r\n    // -------------------------\r\n    \r\n    // Cr√©er un nouveau tableau avec les cartes d√©j√† retourn√©es + la nouvelle carte\r\n    // [...flippedCards] : copie du tableau existant\r\n    // , card : ajout de la nouvelle carte\r\n    const newFlippedCards = [...flippedCards, card];\r\n    \r\n    // Mettre √† jour le state avec le nouveau tableau\r\n    setFlippedCards(newFlippedCards);\r\n\r\n    // -------------------------\r\n    // Si deux cartes sont maintenant retourn√©es\r\n    // -------------------------\r\n    \r\n    if (newFlippedCards.length === 2) {\r\n      // Incr√©menter le compteur de coups (moves + 1)\r\n      setMoves(moves + 1);\r\n\r\n      // -------------------------\r\n      // V√©rifier si les deux cartes ont le m√™me symbole\r\n      // -------------------------\r\n      \r\n      // newFlippedCards[0] : premi√®re carte retourn√©e\r\n      // newFlippedCards[1] : deuxi√®me carte retourn√©e\r\n      // .value : le symbole (emoji) de la carte\r\n      if (newFlippedCards[0].value === newFlippedCards[1].value) {\r\n        // ‚úÖ PAIRE TROUV√âE !\r\n        \r\n        // Ajouter le symbole de la paire trouv√©e au tableau matchedPairs\r\n        const newMatchedPairs = [...matchedPairs, newFlippedCards[0].value];\r\n        setMatchedPairs(newMatchedPairs);\r\n        \r\n        // Vider le tableau des cartes retourn√©es (elles restent visibles car matched)\r\n        setFlippedCards([]);\r\n\r\n        // -------------------------\r\n        // V√©rifier si toutes les paires sont trouv√©es (victoire)\r\n        // -------------------------\r\n        \r\n        // Si le nombre de paires trouv√©es === nombre de symboles uniques\r\n        // Alors le joueur a gagn√© !\r\n        if (newMatchedPairs.length === cardSymbols.length) {\r\n          setGameWon(true);           // Marquer le jeu comme gagn√©\r\n          setIsTimerRunning(false);   // Arr√™ter le chronom√®tre\r\n        }\r\n      } else {\r\n        // ‚ùå PAS DE CORRESPONDANCE\r\n        \r\n        // setTimeout ex√©cute une fonction apr√®s un d√©lai (en millisecondes)\r\n        // Ici : attendre 1000ms (1 seconde) avant de retourner les cartes\r\n        // Cela donne le temps au joueur de voir les deux cartes\r\n        setTimeout(() => {\r\n          setFlippedCards([]); // Vider le tableau = retourner les cartes\r\n        }, 1000); // 1000 millisecondes = 1 seconde\r\n      }\r\n    }\r\n  };\r\n\r\n  // ==========================================================================\r\n  // FONCTION - Formater le temps en format MM:SS\r\n  // ==========================================================================\r\n  \r\n  // Cette fonction convertit un nombre de secondes en format \"minutes:secondes\"\r\n  // Param√®tre : seconds (nombre de secondes, ex: 125)\r\n  // Retourne : une cha√Æne format√©e (ex: \"02:05\")\r\n  const formatTime = (seconds) => {\r\n    // Calculer les minutes : diviser les secondes par 60 et arrondir vers le bas\r\n    // Math.floor() arrondit vers le bas (ex: 2.9 devient 2)\r\n    // Exemple : 125 secondes / 60 = 2.08... => Math.floor = 2 minutes\r\n    const mins = Math.floor(seconds / 60);\r\n    \r\n    // Calculer les secondes restantes : modulo (%) donne le reste de la division\r\n    // Exemple : 125 % 60 = 5 secondes\r\n    const secs = seconds % 60;\r\n    \r\n    // Cr√©er la cha√Æne format√©e avec template literals (backticks `)\r\n    // .toString() : convertir le nombre en cha√Æne\r\n    // .padStart(2, '0') : ajouter un 0 devant si le nombre a moins de 2 chiffres\r\n    // Exemple : 2 => \"02\", 5 => \"05\"\r\n    // R√©sultat final : \"02:05\"\r\n    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\r\n  };\r\n\r\n  // ==========================================================================\r\n  // RENDU JSX - Ce que le composant affiche √† l'√©cran\r\n  // ==========================================================================\r\n  \r\n  // return contient le JSX (HTML dans JavaScript) √† afficher\r\n  return (\r\n    // Div principale avec la classe CSS \"App\"\r\n    <div className=\"App\">\r\n      \r\n      {/* ===================================================================\r\n          COMPOSANT TITLE - Affiche le titre du jeu\r\n          =================================================================== */}\r\n      {/* Utilisation du composant Title avec la prop text */}\r\n      {/* La prop text est pass√©e au composant Title pour afficher \"Memory Game\" */}\r\n      <Title text=\"Memory Game\" />\r\n      \r\n      {/* ===================================================================\r\n          SECTION INFO - Affiche les statistiques du jeu\r\n          =================================================================== */}\r\n      <div className=\"game-info\">\r\n        {/* --- Compteur de coups --- */}\r\n        <div className=\"info-item\">\r\n          <span className=\"info-label\">Coups:</span>\r\n          {/* {moves} : affiche la valeur du state moves (interpolation) */}\r\n          <span className=\"info-value\">{moves}</span>\r\n        </div>\r\n        \r\n        {/* --- Chronom√®tre --- */}\r\n        <div className=\"info-item\">\r\n          <span className=\"info-label\">Temps:</span>\r\n          {/* Appelle formatTime(timer) pour afficher le temps au format MM:SS */}\r\n          <span className=\"info-value\">{formatTime(timer)}</span>\r\n        </div>\r\n        \r\n        {/* --- Compteur de paires --- */}\r\n        <div className=\"info-item\">\r\n          <span className=\"info-label\">Paires:</span>\r\n          {/* Affiche : nombre de paires trouv√©es / nombre total de paires */}\r\n          {/* matchedPairs.length : nombre d'√©l√©ments dans le tableau */}\r\n          {/* cardSymbols.length : 8 (nombre total de paires possibles) */}\r\n          <span className=\"info-value\">{matchedPairs.length}/{cardSymbols.length}</span>\r\n        </div>\r\n      </div>\r\n\r\n      {/* ===================================================================\r\n          GRILLE DE CARTES - Affiche toutes les cartes du jeu\r\n          =================================================================== */}\r\n      <div className=\"cards-grid\">\r\n        {/* .map() parcourt le tableau cards et cr√©e un composant Card pour chaque carte */}\r\n        {/* card : l'√©l√©ment actuel du tableau (objet { id: X, value: emoji }) */}\r\n        {cards.map((card) => (\r\n          // key : identifiant unique requis par React pour les listes\r\n          // Permet √† React de savoir quelle carte a chang√©\r\n          // card : passe l'objet carte complet au composant Card\r\n          // handleCardClick : passe la fonction de clic au composant Card\r\n          // isFlipped : v√©rifie si la carte est dans le tableau flippedCards\r\n          //   .some() retourne true si au moins un √©l√©ment correspond\r\n          //   (c) => c.id === card.id : fonction qui compare les IDs\r\n          // isMatched : v√©rifie si le symbole de la carte est dans matchedPairs\r\n          //   .includes() retourne true si l'√©l√©ment est dans le tableau\r\n          <Card\r\n            key={card.id}\r\n            card={card}\r\n            handleCardClick={handleCardClick}\r\n            isFlipped={flippedCards.some((c) => c.id === card.id)}\r\n            isMatched={matchedPairs.includes(card.value)}\r\n          />\r\n        ))}\r\n      </div>\r\n\r\n      {/* ===================================================================\r\n          MESSAGE DE VICTOIRE - Affich√© seulement si le jeu est gagn√©\r\n          =================================================================== */}\r\n      {/* Rendu conditionnel : affiche le contenu seulement si gameWon est true */}\r\n      {/* Syntaxe : {condition && <element>} */}\r\n      {gameWon && (\r\n        <div className=\"victory-message\">\r\n          <h2>üéâ F√©licitations ! üéâ</h2>\r\n          {/* Affiche les statistiques finales : nombre de coups et temps total */}\r\n          <p>Vous avez gagn√© en {moves} coups et {formatTime(timer)} !</p>\r\n        </div>\r\n      )}\r\n\r\n      {/* ===================================================================\r\n          BOUTON NOUVELLE PARTIE\r\n          =================================================================== */}\r\n      <div className=\"button-container\">\r\n        {/* Composant Button avec deux props : */}\r\n        {/* text : le texte affich√© sur le bouton */}\r\n        {/* onClick : la fonction √† ex√©cuter quand on clique (initializeGame) */}\r\n        <Button text=\"Nouvelle Partie\" onClick={initializeGame} />\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\n// ============================================================================\r\n// EXPORT - Rendre le composant accessible aux autres fichiers\r\n// ============================================================================\r\n\r\n// export default permet d'importer ce composant avec : import App from './App'\r\nexport default App;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}